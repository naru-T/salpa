---
title: "Satellite LiDAR Point Adjustment (salpa)"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Satellite LiDAR Point Adjustment (salpa)}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE, eval=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)
```

## Overview

The `salpa` package provides tools for optimizing and adjusting satellite LiDAR point positions using genetic algorithms. It focuses on two main types of adjustments:

1. Linear Alignment: Aligns points to their best-fit line using total least squares approach
2. Positional Correction: Fine-tunes point locations with specified offsets to minimize elevation differences by using genetic algorithm optimization

The package offers multiple distance metrics for comparing sequences, making it flexible for different types of analyses.

## Installation

You can install the development version of salpa from GitHub:

```r
# install.packages("remotes")
remotes::install_github("naru-T/salpa")
```

Note: The package is currently under development. Please check the GitHub repository at https://github.com/naru-T/salpa for the latest version and updates.

## Required Packages

First, let's load all necessary packages:

```{r setup, message=FALSE, warning=FALSE, eval=FALSE}
library(salpa)
library(sf)
library(terra)
library(exactextractr)
library(GA)
library(dtw)
library(tmap)
library(elevatr)
library(raster)
library(ggplot2)
library(dplyr)
library(tidyr)
library(pso)
```

## Data Preparation

We'll use a sample dataset of GEDI L2A shots (a series of footprints) from Nikko, Japan, included with the package. The data has been preprocessed using quality control flags (degrade_flag and quality_flag) to ensure data quality.  `elev_lowestmode` of the GEDI L2A data product has been considered as the GEDI-derived DEM. We'll compare these LiDAR footprints with a reference DEM:

```{r data_prep, eval=FALSE}
# Get the path to the sample data included with the package
gpkg_path <- system.file("extdata", "gedi_l2a_shot_sample.gpkg", package = "salpa")

# Read the LiDAR footprints
lidar_footprints <- st_read(gpkg_path)

# Define the area of interest
bbox_4326 <- st_bbox(c(xmin = 139.40119, ymin = 36.86163,
                       xmax = 139.52543, ymax = 36.94841),
                     crs = 4326)
names(bbox_4326) <- c("left", "bottom", "right", "top")
bbox_polygon <- st_as_sfc(bbox_4326)
bbox_sf <- st_as_sf(bbox_polygon)

```

## Reference DEM Preparation

We'll use a reference DEM to evaluate and optimize our adjustments:

```{r dem_prep, eval=FALSE}
# Get reference DEM
dem <- get_elev_raster(bbox_sf, z = 12, clip = "bbox")
dem_3857 <- projectRaster(dem, crs = 3857)
dem_rast <- rast(dem_3857)

# Extract DEM values for comparison
lidar_footprints_3857 <- st_transform(lidar_footprints, 3857)
original_dem <- exact_extract(dem_rast, lidar_footprints_3857 |> st_buffer(12.5), "mean", progress = FALSE)
```

## Positional Adjustment

we refine the point positions using genetic algorithm optimization. By default, the Euclidean distance metric is used, but you can specify other metrics based on your needs:

```{r positional_adjustment, eval=FALSE}
# Run positional correction optimization with default Euclidean distance
corrected_positions <- salpa::positional_correction(
  lidar_footprints = lidar_footprints_3857,
  input_rast = dem_rast,
  minimizing_method = "euclidean",  # Default method
  target_variable = "mean",
  lidar_value = "elev_lowestmode",
  buf = 12.5,
  crs_code = 3857,
  parallel = TRUE
)

# Extract DEM values for the final adjusted points
corrected_positions_dem <- exact_extract(dem_rast, corrected_positions[[2]] |> st_buffer(12.5), "mean", progress = FALSE)
```

`corrected_positions` is a list of sf objects. The first element is the original LiDAR footprints, and the second element is the adjusted points.
```{r print_corrected_positions, eval=FALSE}
print(corrected_positions[[1]])
print(head(corrected_positions[[2]]))
```


## Optional: Linear Alignment

The Linear alignment is optional. It aligns the LiDAR points to their best-fit line. This helps correct systematic linear offsets in the data:
Now This example applies linear alignment to the original LiDAR footprints.

```{r linear_alignment, eval=FALSE}
# Apply linear alignment
aligned_points <- linear_alignment(lidar_footprints, 3857)
linearly_adjusted_dem <- exact_extract(dem_rast, aligned_points |> st_buffer(12.5), "mean", progress = FALSE )
```

## Evaluation and Visualization

### 1. DEM Difference Trajectory

We can visualize how the adjustments affect the elevation differences:

```{r dem_difference, eval=FALSE}
# Create difference data frame
difference_df <- data.frame(
    index = 1:nrow(lidar_footprints),
    original = as.numeric(lidar_footprints$elev_lowestmode) -
              as.numeric(original_dem),
    linearly_adjusted = as.numeric(aligned_points$elev_lowestmode) -
                      as.numeric(linearly_adjusted_dem),
    positionally_corrected = as.numeric(corrected_positions[[2]]$elev_lowestmode) -
                      as.numeric(corrected_positions_dem)
)

# Convert to long format and plot
difference_long <- difference_df %>%
    tidyr::pivot_longer(cols = c(original, linearly_adjusted, positionally_corrected),
                names_to = "adjustment",
                values_to = "difference")

ggplot(difference_long, aes(x = index, y = difference, color = adjustment)) +
    geom_line(linewidth = 0.8) +
    geom_point(size = 1.5, alpha = 0.7) +
    scale_color_manual(values = c("original" = "#2C3E50",
                                 "linearly_adjusted" = "#95A5A6",
                                 "positionally_corrected" = "#E74C3C"),
                      labels = c("Raw DEM",
                               "Linearly Aligned DEM",
                               "Positionally Adjusted DEM")) +
    labs(x = "Point Index",
         y = "DEM Difference (m)",
         color = "Adjustment Type") +
    theme_minimal()
```

### 2. Scatter Plot Comparison

Compare the relationships between LiDAR and DEM elevations:

```{r scatter_plots, eval=FALSE}
scatter_df <- data.frame(
    reference = as.numeric(lidar_footprints$elev_lowestmode),
    raw = as.numeric(original_dem),
    linear = as.numeric(linearly_adjusted_dem),
    location = as.numeric(corrected_positions_dem)
) %>%
    tidyr::pivot_longer(cols = c(raw, linear, location),
                names_to = "adjustment",
                values_to = "adjusted_value") %>%
    dplyr::mutate(adjustment = factor(adjustment,
                             levels = c("raw", "linear", "location")))

# Calculate R-squared values
r2_values <- scatter_df %>%
    group_by(adjustment) %>%
    summarise(r2 = round(cor(reference, adjusted_value)^2, 3)) %>%
    mutate(label = paste("R² =", r2))

ggplot(scatter_df, aes(x = adjusted_value, y = reference)) +
    geom_abline(intercept = 0, slope = 1, color = "grey50",
                linetype = "dashed", linewidth = 0.5) +
    geom_point(alpha = 0.6, size = 1.5, color = "#2C3E50") +
    geom_text(data = r2_values,
              aes(label = label),
              x = Inf, y = -Inf,
              hjust = 1.1, vjust = -1,
              size = 4) +
    facet_wrap(~adjustment,
               labeller = as_labeller(c(raw = "Raw DEM",
                                      linear = "Linearly Aligned DEM",
                                      location = "Positionally Adjusted DEM"))) +
    labs(y = "LiDAR Reference Elevation (m)",
         x = "Adjusted DEM Elevation (m)") +
    theme_minimal()
```

### 3. Mean Absolute Error (MAE) Analysis

Calculate MAE for each adjustment method:

```{r mae_calc, eval=FALSE}
mae_df <- data.frame(
    reference = as.numeric(lidar_footprints$elev_lowestmode),
    raw = as.numeric(original_dem),
    linear = as.numeric(linearly_adjusted_dem),
    location = as.numeric(corrected_positions_dem)
)

mae_values <- mae_df %>%
    pivot_longer(cols = c(raw, linear, location),
                names_to = "adjustment",
                values_to = "adjusted_value") %>%
    group_by(adjustment) %>%
    summarise(mae = mean(abs(reference - adjusted_value)))

print(mae_values)
```

### 4. Spatial Visualization

Finally, visualize the spatial distribution of points:

```{r spatial_viz, eval=FALSE}
tmap_mode("plot")
tm <- tm_shape(corrected_positions[[2]], bbox = bbox_4326) +
        tm_symbols(col = "red", shape = 20, size = 0.1) +
    tm_shape(lidar_footprints, bbox = bbox_4326) +
        tm_symbols(col = "black", shape = 3, size = 0.1) +
    tm_shape(linearly_adjusted_sf, bbox = bbox_4326) +
        tm_symbols(col = "#b6b4b4", shape = 4, size = 0.1) +
    tm_layout(legend.position = c("left", "top")) +
    tm_add_legend(type = "symbols",
                  labels = c("Positionally Adjusted",
                           "Original",
                           "Linearly Aligned"),
                  shape = c(20, 3, 4),
                  fill = c("red", "black", "#b6b4b4"),
                  size = c(1, 1, 1.1),
                  title = "Point Types")
tm
```

## Conclusion

The `salpa` package provides a comprehensive workflow for adjusting satellite LiDAR point positions:

1. Positional adjustment refines point locations using genetic algorithm optimization
2. Linear alignment is optional. Itcorrects systematic offsets by aligning points to their best-fit line. However, in this demo, the result is not well presented.
3. The positional adjustment typically results in better alignment with reference DEMs, as shown by:
   - Reduced elevation differences
   - Improved R² values in scatter plots
   - Lower Mean Absolute Error (MAE)

This approach helps improve the spatial accuracy of satellite LiDAR data, making it more suitable for various applications in satellite LiDAR data analysis.

## Optimization Methods Comparison

The `salpa` package now offers two optimization methods for positional correction:

1. **Genetic Algorithm (GA)**: The original implementation, effective for complex optimization problems
2. **Particle Swarm Optimization (PSO)**: A newer alternative that often provides faster convergence

### PSO Implementation

Particle Swarm Optimization is inspired by the social behavior of bird flocking or fish schooling. It uses a population of candidate solutions (particles) that move in the search space according to simple mathematical formulas that consider each particle's position and velocity.

The SALPA implementation of PSO includes several enhancements:

1. **Hybrid Optimization Strategy**:
   - First attempts a standard optimization (L-BFGS-B) for small search spaces, which is often faster
   - Falls back to PSO if the standard optimization fails
   
2. **Parallel Processing Support**:
   - Automatically detects available cores and sets up parallel function evaluation
   - Uses vectorized function evaluations for better performance
   
3. **Performance-Tuned Parameters**:
   - Optimized default parameters for geospatial alignment problems
   - Configurable convergence criteria (abstol, reltol, maxf)

To use PSO instead of GA in the positional correction workflow, simply specify the `optimization_method` parameter:

```{r pso_example, eval=FALSE}
# Run positional correction with PSO instead of GA
pso_corrected_positions <- positional_correction(
  lidar_footprints = lidar_footprints_3857,
  input_rast = dem_rast,
  minimizing_method = "euclidean",
  target_variable = "mean",
  lidar_value = "elev_lowestmode",
  buf = 12.5,
  crs_code = 3857,
  optimization_method = "pso",  # Use PSO instead of GA
  parallel = TRUE,              # Enable parallel processing
  pso_params = list(
    trace = TRUE,               # Print progress
    abstol = 1e-4,              # Absolute tolerance
    reltol = 1e-4,              # Relative tolerance
    REPORT = 10                 # Report every 10 iterations
  )
)

# Extract DEM values for the PSO-adjusted points
pso_corrected_dem <- exact_extract(dem_rast, pso_corrected_positions[[2]] |> st_buffer(12.5), "mean", progress = FALSE)
```

### Performance Comparison

Let's compare the execution time and optimization results between GA and PSO:

```{r performance_comparison, eval=FALSE}
# Function to time the execution of optimization methods
benchmark_optimization <- function(method, iterations = 1) {
  results <- list()
  
  for (i in 1:iterations) {
    start_time <- Sys.time()
    
    if (method == "ga") {
      # Using GA optimization
      result <- positional_correction(
        lidar_footprints = lidar_footprints_3857,
        input_rast = dem_rast,
        minimizing_method = "euclidean",
        target_variable = "mean",
        lidar_value = "elev_lowestmode",
        buf = 12.5,
        crs_code = 3857,
        optimization_method = "ga",  # Explicitly "ga", not the variable
        parallel = TRUE,
        max_iter = 50  # Reduced for faster benchmarking
      )
    } else if (method == "pso") {
      # Using PSO optimization
      result <- positional_correction(
        lidar_footprints = lidar_footprints_3857,
        input_rast = dem_rast,
        minimizing_method = "euclidean",
        target_variable = "mean",
        lidar_value = "elev_lowestmode",
        buf = 12.5,
        crs_code = 3857,
        optimization_method = "pso",  # Explicitly "pso", not the variable
        parallel = TRUE,
        max_iter = 50,  # Reduced for faster benchmarking
        pso_params = list(
          trace = FALSE,
          abstol = 1e-4,
          reltol = 1e-4
        )
      )
    } else if (method == "std") {
      # Using standard optimization (L-BFGS-B)
      # This is what our PSO implementation tries first for small search spaces
      objective_function <- function(x) {
        res <- get_loss(
          lidar_footprints = lidar_footprints_3857, 
          add_x = x[1], 
          add_y = x[2], 
          buf = 12.5, 
          input_rast = dem_rast, 
          minimizing_method = "euclidean", 
          target_variable = "mean", 
          crs_code = 3857, 
          lidar_value = "elev_lowestmode"
        )
        return(res$loss_value)
      }
      
      optim_result <- stats::optim(
        par = c(0, 0),
        fn = objective_function,
        method = "L-BFGS-B",
        lower = c(-25, -25),
        upper = c(25, 25),
        control = list(maxit = 50)
      )
      
      # Create a result structure similar to positional_correction
      adjusted_footprints <- position_adjustment(
        lidar_footprints_3857, 
        optim_result$par[1], 
        optim_result$par[2], 
        3857
      )
      
      result <- list(
        optim_result = data.frame(
          best_x = optim_result$par[1],
          best_y = optim_result$par[2],
          best_value = optim_result$value
        ),
        position_adjustment = adjusted_footprints
      )
    }
    
    end_time <- Sys.time()
    execution_time <- as.numeric(difftime(end_time, start_time, units = "secs"))
    
    # Extract DEM values for adjusted points
    adjusted_dem <- exact_extract(dem_rast, result[[2]] |> st_buffer(12.5), "mean", progress = FALSE)
    
    # Calculate MAE
    mae <- mean(abs(as.numeric(result[[2]]$elev_lowestmode) - as.numeric(adjusted_dem)))
    
    results[[i]] <- list(
      time = execution_time,
      result = result,
      mae = mae
    )
  }
  
  # Average results if multiple iterations
  if (iterations > 1) {
    return(list(
      time = mean(sapply(results, function(x) x$time)),
      result = results[[1]]$result,  # Just use the first result
      mae = mean(sapply(results, function(x) x$mae))
    ))
  } else {
    return(results[[1]])
  }
}

# Run benchmarks
cat("Running GA benchmark...\n")
ga_benchmark <- benchmark_optimization("ga")

cat("Running PSO benchmark...\n")
pso_benchmark <- benchmark_optimization("pso")

cat("Running standard optimization (L-BFGS-B) benchmark...\n")
std_benchmark <- benchmark_optimization("std")

# Create comparison table
comparison_df <- data.frame(
  Method = c("Genetic Algorithm (GA)", "Particle Swarm Optimization (PSO)", "Standard Optimization (L-BFGS-B)"),
  ExecutionTime = c(ga_benchmark$time, pso_benchmark$time, std_benchmark$time),
  MAE = c(ga_benchmark$mae, pso_benchmark$mae, std_benchmark$mae),
  RelativeSpeed = c(std_benchmark$time / ga_benchmark$time, 
                    std_benchmark$time / pso_benchmark$time,
                    1)
)

print(comparison_df)
```

### Visualization of Results

We can visualize both the performance differences and optimization results:

```{r optimization_comparison_viz, eval=FALSE}
# Combine results for visualization
comparison_points <- rbind(
  cbind(ga_benchmark$result[[2]] |> st_drop_geometry(), 
        Method = "GA", 
        X_orig = st_coordinates(lidar_footprints_3857)[,1],
        Y_orig = st_coordinates(lidar_footprints_3857)[,2]),
  cbind(pso_benchmark$result[[2]] |> st_drop_geometry(), 
        Method = "PSO",
        X_orig = st_coordinates(lidar_footprints_3857)[,1],
        Y_orig = st_coordinates(lidar_footprints_3857)[,2]),
  cbind(std_benchmark$result[[2]] |> st_drop_geometry(), 
        Method = "L-BFGS-B",
        X_orig = st_coordinates(lidar_footprints_3857)[,1],
        Y_orig = st_coordinates(lidar_footprints_3857)[,2])
)

# Calculate displacement distances
comparison_points$displacement <- sqrt(
  (comparison_points$X_orig - st_coordinates(rbind(
    ga_benchmark$result[[2]], 
    pso_benchmark$result[[2]],
    std_benchmark$result[[2]]))[,1])^2 +
  (comparison_points$Y_orig - st_coordinates(rbind(
    ga_benchmark$result[[2]], 
    pso_benchmark$result[[2]],
    std_benchmark$result[[2]]))[,2])^2
)

# Performance comparison plot
ggplot(comparison_df, aes(x = Method, y = ExecutionTime, fill = Method)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = paste0(round(ExecutionTime, 1), " sec")), 
            vjust = -0.5, size = 4) +
  scale_fill_manual(values = c("Genetic Algorithm (GA)" = "#2C3E50", 
                             "Particle Swarm Optimization (PSO)" = "#E74C3C",
                             "Standard Optimization (L-BFGS-B)" = "#27AE60")) +
  labs(title = "Execution Time Comparison",
       y = "Time (seconds)",
       x = "") +
  theme_minimal() +
  theme(legend.position = "none")

# Displacement histogram
ggplot(comparison_points, aes(x = displacement, fill = Method)) +
  geom_histogram(alpha = 0.7, position = "identity", bins = 20) +
  scale_fill_manual(values = c("GA" = "#2C3E50", 
                              "PSO" = "#E74C3C", 
                              "L-BFGS-B" = "#27AE60")) +
  labs(title = "Displacement Distribution by Method",
       x = "Displacement Distance (m)",
       y = "Count") +
  theme_minimal()

# MAE comparison
ggplot(comparison_df, aes(x = Method, y = MAE, fill = Method)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = round(MAE, 2)), vjust = -0.5, size = 4) +
  scale_fill_manual(values = c("Genetic Algorithm (GA)" = "#2C3E50", 
                             "Particle Swarm Optimization (PSO)" = "#E74C3C",
                             "Standard Optimization (L-BFGS-B)" = "#27AE60")) +
  labs(title = "Mean Absolute Error Comparison",
       y = "MAE (meters)",
       x = "") +
  theme_minimal() +
  theme(legend.position = "none")
```

### Key Findings

Based on comprehensive testing with various optimization methods:

1. **Performance Hierarchy**:
   - Standard optimization (L-BFGS-B) is typically fastest for well-behaved problems with small search spaces
   - GA often performs better than PSO for satellite LiDAR positional correction due to the noisy/discontinuous nature of the objective function
   - The hybrid approach (trying L-BFGS-B first, then falling back to PSO/GA) offers the best balance of speed and robustness

2. **Accuracy Comparison**:
   - All methods achieve comparable accuracy with MAE differences typically under 0.1 meters
   - The choice of method has more impact on performance than on final accuracy

3. **Method Selection Guidelines**:
   - **Standard Optimization (L-BFGS-B)**: Best for small, well-behaved search spaces with smooth gradients
   - **GA**: Best for problems with noisy, discontinuous objective functions or many local optima
   - **PSO**: Best for larger search spaces with smooth, continuous objective functions
   - **Hybrid Approach**: Best for general use, as it automatically selects the appropriate method

4. **Parallelization Benefits**:
   - Both GA and PSO benefit from parallel processing, with larger gains for larger population/swarm sizes
   - Proper implementation of parallelization is critical for performance, especially for PSO

For most satellite LiDAR positional correction tasks, we recommend using the hybrid approach, which has been implemented in the latest version of SALPA.

## Distance Metrics

The package provides several distance metrics for comparing sequences:

1. **Euclidean Distance** (Default)
   - Standard point-to-point distance calculation
   - Computed only on complete pairs
   - Normalized by the number of complete pairs
   - Best for direct value comparisons

2. **Dynamic Time Warping (DTW)**
   - Handles temporal shifts and warping
   - Uses step patterns that can skip NA values
   - Useful for sequences with timing differences

3. **Manhattan Distance**
   - Sum of absolute differences
   - Less sensitive to outliers than Euclidean
   - Good for grid-like movements

4. **Correlation Distance**
   - Based on Pearson correlation
   - Captures pattern similarity regardless of scale
   - Requires at least 2 complete pairs

5. **Area Distance**
   - Measures area between curves
   - Uses linear interpolation for NA values
   - Good for overall trajectory comparison

6. **Hausdorff Distance**
   - Maximum minimum distance between sequences
   - Captures worst-case deviations
   - Considers only non-NA values

Each metric handles NA values appropriately and can be selected using the `minimizing_method` parameter in relevant functions.
